package com.opticdev.parsers.es7

// Generated by Marvin

import com.opticdev.marvin.common.ast._
import com.opticdev.marvin.runtime.mutators.{AstMutator, NodeMutatorMap}
import com.opticdev.marvin.runtime.pattern._
import com.opticdev.marvin.runtime.predicates.isNull

import scala.util.Try

object JsSourceInterface extends NodeMutatorMap {

  implicit val nodeMutatorMap = this

  implicit val patternMatcher = new PatternMatcher {}

  class UnaryExpression extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      CodePattern(SymbolComponent("typeof"), Space, ChildNode("argument"))
    }

    override val nodeType: String = "UnaryExpression"
  }

  class UpdateExpression extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      CodePattern(ChildNode("argument"), PropertyBinding("operator"))
    }

    override val nodeType: String = "UpdateExpression"
  }

  class SequenceExpression extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      CodePattern(ChildNodeList("expressions", ", "))
    }

    override val nodeType: String = "SequenceExpression"
  }

  class CallExpression extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      CodePattern(ChildNode("callee"), SymbolComponent("("), ChildNodeList("arguments", ", "), SymbolComponent(")"))
    }

    override val nodeType: String = "CallExpression"
  }

  class CatchClause extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      CodePattern(SymbolComponent("catch"), Space, SymbolComponent("("), Space, ChildNode("param"), Space, SymbolComponent(")"), Space, ChildNode("body"))
    }

    override val nodeType: String = "CatchClause"
  }

  class IfStatement extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      val alternateisNull: Boolean = isNull.evaluate(node.properties.getOrElse("alternate", AstNull))
      if (!(alternateisNull)) {
        CodePattern(SymbolComponent("if"), Space, SymbolComponent("("), Space, ChildNode("test"), Space, SymbolComponent(")"), Space, ChildNode("consequent"), Space, SymbolComponent("else"), Space, ChildNode("alternate"))
      }
      else {
        CodePattern(SymbolComponent("if"), Space, SymbolComponent("("), Space, ChildNode("test"), Space, SymbolComponent(")"), Space, ChildNode("consequent"))
      }
    }

    override val nodeType: String = "IfStatement"
  }

  class BlockStatement extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      CodePattern(SymbolComponent("{"), Line, ChildNodeList("body", "\n"), Line, SymbolComponent("}"))
    }

    override val nodeType: String = "BlockStatement"
  }

  class SwitchStatement extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      CodePattern(SymbolComponent("switch"), Space, SymbolComponent("("), ChildNode("discriminant"), SymbolComponent(")"), Space, SymbolComponent("{"), Line, ChildNodeList("cases", "\n"), Line, SymbolComponent("}"))
    }

    override val nodeType: String = "SwitchStatement"
  }

  class SwitchCase extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      val testIsNull: Boolean = isNull.evaluate(node.properties.getOrElse("alternate", AstNull))
      if (testIsNull) {
        CodePattern(SymbolComponent("default"), SymbolComponent(":"), Line, ChildNodeList("consequent", "\n"))
      } else {
        CodePattern(SymbolComponent("case"), Space, ChildNode("test"), SymbolComponent(":"), Space, ChildNodeList("consequent", "\n"))
      }
    }

    override val nodeType: String = "SwitchCase"
  }

  class NewExpression extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      CodePattern(SymbolComponent("new"), Space, ChildNode("callee"), SymbolComponent("("), Space, ChildNodeList("arguments", ", "), Space, SymbolComponent(")"))
    }

    override val nodeType: String = "NewExpression"
  }

  class LogicalExpression extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      CodePattern(ChildNode("left"), Space, PropertyBinding("operator"), Space, ChildNode("right"))
    }

    override val nodeType: String = "LogicalExpression"
  }

  class ClassBody extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      CodePattern(SymbolComponent("{}"))
    }

    override val nodeType: String = "ClassBody"
  }

  class ContinueStatement extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      CodePattern(SymbolComponent("continue;"))
    }

    override val nodeType: String = "ContinueStatement"
  }

  class Literal extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      val valueisNull: Boolean = isNull.evaluate(node.properties.getOrElse("value", AstNull))
      if (valueisNull) {
        CodePattern(SymbolComponent("null"))
      }
      else {
        node.properties("value") match {
          case s: AstString => CodePattern(SymbolComponent("'"), PropertyBinding("value"), SymbolComponent("'"))
          case n: AstNumber => CodePattern(PropertyBinding("value"))
          case n: AstBoolean => CodePattern(PropertyBinding("value"))
          case _ => CodePattern(PropertyBinding("value"))
        }
      }
    }

    override val nodeType: String = "Literal"
  }

  class StringLiteral extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      val valueisNull: Boolean = isNull.evaluate(node.properties.getOrElse("value", AstNull))
      if (valueisNull) {
        CodePattern(SymbolComponent("null"))
      }
      else {
        CodePattern(SymbolComponent("\""), PropertyBinding("value"), SymbolComponent("\""))
      }
    }

    override val nodeType: String = "Literal"
  }

  class ConditionalExpression extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      CodePattern(ChildNode("test"), Space, SymbolComponent("?"), Line, ChildNode("consequent"), Space, SymbolComponent(":"), Line, ChildNode("alternate"))
    }

    override val nodeType: String = "ConditionalExpression"
  }

  class AssignmentExpression extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      CodePattern(ChildNode("left"), Space, PropertyBinding("operator"), Space, ChildNode("right"))
    }

    override val nodeType: String = "AssignmentExpression"
  }

  class ClassDeclaration extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      val superClassisNull: Boolean = isNull.evaluate(node.properties.getOrElse("superClass", AstNull))
      if (superClassisNull) {
        CodePattern(SymbolComponent("class"), Space, ChildNode("id"), Space, ChildNode("body"))
      }
      else {
        CodePattern(SymbolComponent("class"), Space, ChildNode("id"), Space, SymbolComponent("extends"), Space, ChildNode("superClass"), Space, ChildNode("body"))
      }
    }

    override val nodeType: String = "ClassDeclaration"
  }

  class Program extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      CodePattern(ChildNodeList("body", "\n\n"))
    }

    override val nodeType: String = "Program"
  }

  class MemberExpression extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      CodePattern(ChildNode("object"), SymbolComponent("."), ChildNode("property"))
    }

    override val nodeType: String = "MemberExpression"
  }

  class VariableDeclarator extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      val initisNull: Boolean = isNull.evaluate(node.properties.getOrElse("init", AstNull))
      if (initisNull) {
        CodePattern(ChildNode("id"))
      }
      else {
        CodePattern(ChildNode("id"), Space, SymbolComponent("="), Space, ChildNode("init"))
      }
    }

    override val nodeType: String = "VariableDeclarator"
  }

  class EmptyStatement extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      CodePattern(SymbolComponent(";"))
    }

    override val nodeType: String = "EmptyStatement"
  }

  class ReturnStatement extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      val argumentisNull: Boolean = isNull.evaluate(node.properties.getOrElse("argument", AstNull))
      if (argumentisNull) {
        CodePattern(SymbolComponent("return;"))
      }
      else {
        CodePattern(SymbolComponent("return"), Space, ChildNode("argument"), SymbolComponent(";"))
      }
    }

    override val nodeType: String = "ReturnStatement"
  }

  class WhileStatement extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      CodePattern(SymbolComponent("while"), Space, SymbolComponent("("), Space, ChildNode("test"), Space, SymbolComponent(")"), Space, ChildNode("body"))
    }

    override val nodeType: String = "WhileStatement"
  }

  class VariableDeclaration extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      CodePattern(PropertyBinding("kind"), Space, ChildNodeList("declarations", ", "), SymbolComponent(";"))
    }

    override val nodeType: String = "VariableDeclaration"
  }

  class TryStatement extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      CodePattern(SymbolComponent("try"), Space, ChildNode("block"), Space, ChildNode("handler"))
    }

    override val nodeType: String = "TryStatement"
  }

  class ForStatement extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 0.6666666666666666
    {
      val initisNull: Boolean = isNull.evaluate(node.properties.getOrElse("init", AstNull))
      if (!(initisNull)) {
        CodePattern(SymbolComponent("for"), Space, SymbolComponent("("), Space, ChildNode("init"), SymbolComponent(";"), Space, ChildNode("test"), SymbolComponent(";"), Space, ChildNode("update"), Space, SymbolComponent(")"), Space, ChildNode("body"))
      }
      else {
        CodePattern(SymbolComponent("for"), Space, SymbolComponent("("), Space, SymbolComponent(";"), Space, ChildNode("test"), SymbolComponent(";"), Space, ChildNode("update"), Space, SymbolComponent(")"), Space, ChildNode("body"))
      }
    }

    override val nodeType: String = "ForStatement"
  }

  class ForInStatement extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      CodePattern(SymbolComponent("for"), Space, SymbolComponent("("), Space, ChildNode("left"), Space, SymbolComponent("in"), Space, ChildNode("right"), Space, SymbolComponent(")"), Space, ChildNode("body"))
    }

    override val nodeType: String = "ForInStatement"
  }

  class MethodDefinition extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      CodePattern(ChildNode("key"), ChildNode("value"))
    }

    override val nodeType: String = "MethodDefinition"
  }

  class BinaryExpression extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      CodePattern(ChildNode("left"), Space, PropertyBinding("operator"), Space, ChildNode("right"))
    }

    override val nodeType: String = "BinaryExpression"
  }

  class FunctionExpression extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      val idisNull: Boolean = isNull.evaluate(node.properties.getOrElse("id", AstNull))
      if (!(idisNull)) {
        CodePattern(SymbolComponent("function"), Space, ChildNode("id"), SymbolComponent("("), Space, ChildNodeList("params", ", "), Space, SymbolComponent(")"), Space, ChildNode("body"))
      }
      else {
        CodePattern(SymbolComponent("function("), Space, ChildNodeList("params", ", "), Space, SymbolComponent(")"), Space, ChildNode("body"))
      }
    }

    override val nodeType: String = "FunctionExpression"
  }

  class Identifier extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      CodePattern(PropertyBinding("name"))
    }

    override val nodeType: String = "Identifier"
  }

  class ObjectExpression extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      val moreThan3Properties = Try(node.properties("properties").asInstanceOf[AstArray].children.size > 3).getOrElse(false)
      if (moreThan3Properties) {
        CodePattern(SymbolComponent("{"), Space, ChildNodeList("properties", ",\n"), Space, SymbolComponent("}"))
      } else {
        CodePattern(SymbolComponent("{"), Space, ChildNodeList("properties", ", "), Space, SymbolComponent("}"))
      }
    }

    override val nodeType: String = "ObjectExpression"
  }

  class ThrowStatement extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      CodePattern(SymbolComponent("throw"), Space, ChildNode("argument"), SymbolComponent(";"))
    }

    override val nodeType: String = "ThrowStatement"
  }

  class BreakStatement extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      CodePattern(SymbolComponent("break;"))
    }

    override val nodeType: String = "BreakStatement"
  }

  class FunctionDeclaration extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      CodePattern(SymbolComponent("function"), Space, ChildNode("id"), SymbolComponent("()"), Space, ChildNode("body"))
    }

    override val nodeType: String = "FunctionDeclaration"
  }

  class ArrayExpression extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      CodePattern(SymbolComponent("["), Space, ChildNodeList("elements", ",\n"), Space, SymbolComponent("]"))
    }

    override val nodeType: String = "ArrayExpression"
  }

  class Property extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      CodePattern(ChildNode("key"), SymbolComponent(":"), Space, ChildNode("value"))
    }

    override val nodeType: String = "Property"
  }

  class ThisExpression extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      CodePattern(SymbolComponent("this"))
    }

    override val nodeType: String = "ThisExpression"
  }

  class ExpressionStatement extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      CodePattern(ChildNode("expression"), SymbolComponent(";"))
    }

    override val nodeType: String = "ExpressionStatement"
  }

  //JSX Plugin

  class JSXAttribute extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      CodePattern(ChildNode("name"), SymbolComponent("="), ChildNode("value"))
    }

    override val nodeType: String = "JSXAttribute"
  }

  class JSXSpreadAttribute extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      CodePattern(SymbolComponent("{"), SymbolComponent("..."), ChildNode("argument"), SymbolComponent("}"))
    }

    override val nodeType: String = "JSXSpreadAttribute"
  }

  class JSXText extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      CodePattern(PropertyBinding("value"))
    }

    override val nodeType: String = "JSXText"
  }

  class JSXIdentifier extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      CodePattern(PropertyBinding("name"))
    }

    override val nodeType: String = "JSXIdentifier"
  }

  class JSXExpressionContainer extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      CodePattern(ChildNode("expression"))
    }

    override val nodeType: String = "JSXExpressionContainer"
  }

  class JSXFragment extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      CodePattern(ChildNode("JSXOpeningFragment"), Line, ChildNodeList("elements", ",\n"), Line, ChildNode("JSXClosingFragment"))
    }

    override val nodeType: String = "JSXFragment"
  }

  class JSXOpeningFragment extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      CodePattern(SymbolComponent("<>"))
    }

    override val nodeType: String = "JSXOpeningFragment"
  }

  class JSXClosingFragment extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      CodePattern(SymbolComponent("</>"))
    }

    override val nodeType: String = "JSXClosingFragment"
  }

  class JSXOpeningElement extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      val moreThan1Attribute = Try(node.properties("attributes").asInstanceOf[AstArray].children.size > 1).getOrElse(false)
      val moreThan0Attributes = Try(node.properties("attributes").asInstanceOf[AstArray].children.size > 0).getOrElse(false)
      val isSelfClosingTrue = Try(node.properties("selfClosing").asInstanceOf[AstBoolean].value).getOrElse(false)

      if (moreThan1Attribute) {
        if (isSelfClosingTrue) {
          CodePattern(SymbolComponent("<"), ChildNode("name"), if (moreThan0Attributes) Line else Empty, ChildNodeList("attributes", "\n"), Line, SymbolComponent("/>"))
        } else {
          CodePattern(SymbolComponent("<"), ChildNode("name"), if (moreThan0Attributes) Line else Empty, ChildNodeList("attributes", "\n"), Line, SymbolComponent(">"))
        }
      } else {
        if (isSelfClosingTrue) {
          CodePattern(SymbolComponent("<"), ChildNode("name"), if (moreThan0Attributes) Space else Empty, ChildNodeList("attributes", "\n"), SymbolComponent("/>"))
        } else {
          CodePattern(SymbolComponent("<"), ChildNode("name"), if (moreThan0Attributes) Space else Empty, ChildNodeList("attributes", "\n"), SymbolComponent(">"))
        }
      }

    }

    override val nodeType: String = "JSXOpeningElement"
  }

  class JSXClosingElement extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {
      CodePattern(SymbolComponent("</"), ChildNode("name"), SymbolComponent(">"))
    }

    override val nodeType: String = "JSXClosingElement"
  }

  class JSXElement extends AstMutator {
    def expectedPattern(node: BaseAstNode): CodePattern =
    // Accuracy = 1.0
    {

      val isClosingElementNull: Boolean = isNull.evaluate(node.properties.getOrElse("closingElement", AstNull))
      val moreThan1Children = Try(node.properties("children").asInstanceOf[AstArray].children.size > 1).getOrElse(false)

      if (isClosingElementNull) {
        CodePattern(ChildNode("openingElement"))
      } else {
        if (moreThan1Children) {
          CodePattern(ChildNode("openingElement"), Line, ChildNodeList("children", "\n"), Line, ChildNode("closingElement"))
        } else {
          CodePattern(ChildNode("openingElement"), ChildNodeList("children", " "),  ChildNode("closingElement"))
        }
      }
    }

    override val nodeType: String = "JSXClosingElement"
  }

  val mapping: Map[String, AstMutator] = Map(("UnaryExpression", new UnaryExpression), ("UpdateExpression", new UpdateExpression), ("SequenceExpression", new SequenceExpression), ("CallExpression", new CallExpression), ("CatchClause", new CatchClause), ("IfStatement", new IfStatement), ("BlockStatement", new BlockStatement), ("SwitchStatement", new SwitchStatement), ("SwitchCase", new SwitchCase), ("NewExpression", new NewExpression), ("LogicalExpression", new LogicalExpression), ("ClassBody", new ClassBody), ("ContinueStatement", new ContinueStatement), ("Literal", new Literal), ("StringLiteral", new StringLiteral), ("ConditionalExpression", new ConditionalExpression), ("AssignmentExpression", new AssignmentExpression), ("ClassDeclaration", new ClassDeclaration), ("Program", new Program), ("MemberExpression", new MemberExpression), ("VariableDeclarator", new VariableDeclarator), ("EmptyStatement", new EmptyStatement), ("ReturnStatement", new ReturnStatement), ("WhileStatement", new WhileStatement), ("VariableDeclaration", new VariableDeclaration), ("TryStatement", new TryStatement), ("ForStatement", new ForStatement), ("ForInStatement", new ForInStatement), ("MethodDefinition", new MethodDefinition), ("BinaryExpression", new BinaryExpression), ("FunctionExpression", new FunctionExpression), ("Identifier", new Identifier), ("ObjectExpression", new ObjectExpression), ("ThrowStatement", new ThrowStatement), ("BreakStatement", new BreakStatement), ("FunctionDeclaration", new FunctionDeclaration), ("ArrayExpression", new ArrayExpression), ("Property", new Property), ("ThisExpression", new ThisExpression), ("ExpressionStatement", new ExpressionStatement), ("JSXAttribute", new JSXAttribute), ("JSXSpreadAttribute", new JSXSpreadAttribute), ("JSXText", new JSXText), ("JSXIdentifier", new JSXIdentifier), ("JSXExpressionContainer", new JSXExpressionContainer), ("JSXFragment", new JSXFragment), ("JSXOpeningFragment", new JSXOpeningFragment), ("JSXClosingFragment", new JSXClosingFragment), ("JSXOpeningElement", new JSXOpeningElement), ("JSXClosingElement", new JSXClosingElement), ("JSXElement", new JSXElement))

}